/*
 * ARTIKCloudAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package cloud.artik.api.controllers;

import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import cloud.artik.api.*;
import cloud.artik.api.models.*;
import cloud.artik.api.exceptions.*;
import cloud.artik.api.http.client.HttpClient;
import cloud.artik.api.http.client.HttpContext;
import cloud.artik.api.http.request.HttpRequest;
import cloud.artik.api.http.response.HttpResponse;
import cloud.artik.api.http.response.HttpStringResponse;
import cloud.artik.api.http.client.APICallBack;
import cloud.artik.api.controllers.syncwrapper.APICallBackCatcher;

public class MessagesController extends BaseController {    
    //private static variables for the singleton pattern
    private static Object syncObject = new Object();
    private static MessagesController instance = null;

    /**
     * Singleton pattern implementation 
     * @return The singleton instance of the MessagesController class 
     */
    public static MessagesController getInstance() {
        synchronized (syncObject) {
            if (null == instance) {
                instance = new MessagesController();
            }
        }
        return instance;
    }

    /**
     * Get normalized message presence
     * @param    startDate    Required parameter: startDate
     * @param    endDate    Required parameter: endDate
     * @param    interval    Required parameter: String representing grouping interval. One of: 'minute' (1 hour limit), 'hour' (1 day limit), 'day' (31 days limit), 'month' (1 year limit), or 'year' (10 years limit).
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @return    Returns the FieldPresenceEnvelope response from the API call 
     */
    public FieldPresenceEnvelope getFieldPresence(
                final long startDate,
                final long endDate,
                final String interval,
                final String sdid,
                final String fieldPresence
    ) throws Throwable {
        APICallBackCatcher<FieldPresenceEnvelope> callback = new APICallBackCatcher<FieldPresenceEnvelope>();
        getFieldPresenceAsync(startDate, endDate, interval, sdid, fieldPresence, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get normalized message presence
     * @param    startDate    Required parameter: startDate
     * @param    endDate    Required parameter: endDate
     * @param    interval    Required parameter: String representing grouping interval. One of: 'minute' (1 hour limit), 'hour' (1 day limit), 'day' (31 days limit), 'month' (1 year limit), or 'year' (10 years limit).
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @return    Returns the void response from the API call 
     */
    public void getFieldPresenceAsync(
                final long startDate,
                final long endDate,
                final String interval,
                final String sdid,
                final String fieldPresence,
                final APICallBack<FieldPresenceEnvelope> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages/presence");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5558789583999709959L;
            {
                    put( "startDate", startDate );
                    put( "endDate", endDate );
                    put( "interval", interval );
                    put( "sdid", sdid );
                    put( "fieldPresence", fieldPresence );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5224576607279519595L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            FieldPresenceEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<FieldPresenceEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Normalized Message Histogram
     * @param    startDate    Required parameter: Timestamp of earliest message (in milliseconds since epoch).
     * @param    endDate    Required parameter: Timestamp of latest message (in milliseconds since epoch).
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    field    Optional parameter: Message field being queried for building histogram.
     * @param    interval    Optional parameter: Interval of time for building histogram blocks. (Valid values: minute, hour, day, month, year)
     * @return    Returns the AggregatesHistogramResponse response from the API call 
     */
    public AggregatesHistogramResponse getAggregatesHistogram(
                final long startDate,
                final long endDate,
                final String sdid,
                final String field,
                final String interval
    ) throws Throwable {
        APICallBackCatcher<AggregatesHistogramResponse> callback = new APICallBackCatcher<AggregatesHistogramResponse>();
        getAggregatesHistogramAsync(startDate, endDate, sdid, field, interval, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Normalized Message Histogram
     * @param    startDate    Required parameter: Timestamp of earliest message (in milliseconds since epoch).
     * @param    endDate    Required parameter: Timestamp of latest message (in milliseconds since epoch).
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    field    Optional parameter: Message field being queried for building histogram.
     * @param    interval    Optional parameter: Interval of time for building histogram blocks. (Valid values: minute, hour, day, month, year)
     * @return    Returns the void response from the API call 
     */
    public void getAggregatesHistogramAsync(
                final long startDate,
                final long endDate,
                final String sdid,
                final String field,
                final String interval,
                final APICallBack<AggregatesHistogramResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages/analytics/histogram");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4887192762002839680L;
            {
                    put( "startDate", startDate );
                    put( "endDate", endDate );
                    put( "sdid", sdid );
                    put( "field", field );
                    put( "interval", interval );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5600451473536806547L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            AggregatesHistogramResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<AggregatesHistogramResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Send Actions
     * @param    data    Required parameter: Actions that are passed in the body
     * @return    Returns the MessageIDEnvelope response from the API call 
     */
    public MessageIDEnvelope createSendActions(
                final Actions data
    ) throws Throwable {
        APICallBackCatcher<MessageIDEnvelope> callback = new APICallBackCatcher<MessageIDEnvelope>();
        createSendActionsAsync(data, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Send Actions
     * @param    data    Required parameter: Actions that are passed in the body
     * @return    Returns the void response from the API call 
     */
    public void createSendActionsAsync(
                final Actions data,
                final APICallBack<MessageIDEnvelope> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/actions");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4705034505051814551L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(data));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MessageIDEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MessageIDEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Send Message
     * @param    data    Required parameter: Message object that is passed in the body
     * @return    Returns the MessageIDEnvelope response from the API call 
     */
    public MessageIDEnvelope createSendMessage(
                final Message data
    ) throws Throwable {
        APICallBackCatcher<MessageIDEnvelope> callback = new APICallBackCatcher<MessageIDEnvelope>();
        createSendMessageAsync(data, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Send Message
     * @param    data    Required parameter: Message object that is passed in the body
     * @return    Returns the void response from the API call 
     */
    public void createSendMessageAsync(
                final Message data,
                final APICallBack<MessageIDEnvelope> callBack
    ) throws JsonProcessingException {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages");
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5197751553133648163L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().postBody(_queryUrl, _headers, APIHelper.serialize(data));

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            MessageIDEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<MessageIDEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Message Snapshots
     * @param    sdids    Required parameter: Device IDs for which the snapshots are requested. Max 100 device ids per call.
     * @param    includeTimestamp    Optional parameter: Indicates whether to return timestamps of the last update for each field.
     * @return    Returns the SnapshotResponses response from the API call 
     */
    public SnapshotResponses getMessageSnapshots(
                final String sdids,
                final Boolean includeTimestamp
    ) throws Throwable {
        APICallBackCatcher<SnapshotResponses> callback = new APICallBackCatcher<SnapshotResponses>();
        getMessageSnapshotsAsync(sdids, includeTimestamp, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Message Snapshots
     * @param    sdids    Required parameter: Device IDs for which the snapshots are requested. Max 100 device ids per call.
     * @param    includeTimestamp    Optional parameter: Indicates whether to return timestamps of the last update for each field.
     * @return    Returns the void response from the API call 
     */
    public void getMessageSnapshotsAsync(
                final String sdids,
                final Boolean includeTimestamp,
                final APICallBack<SnapshotResponses> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages/snapshots");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 4749941760023456929L;
            {
                    put( "sdids", sdids );
                    put( "includeTimestamp", includeTimestamp );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5477665056207450725L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            SnapshotResponses _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<SnapshotResponses>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Normalized Actions
     * @param    uid    Optional parameter: User ID. If not specified, assume that of the current authenticated user. If specified, it must be that of a user for which the current authenticated user has read access to.
     * @param    ddid    Optional parameter: Destination device ID of the actions being searched.
     * @param    mid    Optional parameter: The message ID being searched.
     * @param    offset    Optional parameter: A string that represents the starting item, should be the value of 'next' field received in the last response. (required for pagination)
     * @param    count    Optional parameter: count
     * @param    startDate    Optional parameter: startDate
     * @param    endDate    Optional parameter: endDate
     * @param    order    Optional parameter: Desired sort order: 'asc' or 'desc'
     * @return    Returns the NormalizedActionsEnvelope response from the API call 
     */
    public NormalizedActionsEnvelope getNormalizedActions(
                final String uid,
                final String ddid,
                final String mid,
                final String offset,
                final Integer count,
                final Long startDate,
                final Long endDate,
                final String order
    ) throws Throwable {
        APICallBackCatcher<NormalizedActionsEnvelope> callback = new APICallBackCatcher<NormalizedActionsEnvelope>();
        getNormalizedActionsAsync(uid, ddid, mid, offset, count, startDate, endDate, order, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Normalized Actions
     * @param    uid    Optional parameter: User ID. If not specified, assume that of the current authenticated user. If specified, it must be that of a user for which the current authenticated user has read access to.
     * @param    ddid    Optional parameter: Destination device ID of the actions being searched.
     * @param    mid    Optional parameter: The message ID being searched.
     * @param    offset    Optional parameter: A string that represents the starting item, should be the value of 'next' field received in the last response. (required for pagination)
     * @param    count    Optional parameter: count
     * @param    startDate    Optional parameter: startDate
     * @param    endDate    Optional parameter: endDate
     * @param    order    Optional parameter: Desired sort order: 'asc' or 'desc'
     * @return    Returns the void response from the API call 
     */
    public void getNormalizedActionsAsync(
                final String uid,
                final String ddid,
                final String mid,
                final String offset,
                final Integer count,
                final Long startDate,
                final Long endDate,
                final String order,
                final APICallBack<NormalizedActionsEnvelope> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/actions");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5365861527986606665L;
            {
                    put( "uid", uid );
                    put( "ddid", ddid );
                    put( "mid", mid );
                    put( "offset", offset );
                    put( "count", count );
                    put( "startDate", startDate );
                    put( "endDate", endDate );
                    put( "order", order );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5741886758608992735L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            NormalizedActionsEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<NormalizedActionsEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Last Normalized Message
     * @param    count    Optional parameter: Number of items to return per query.
     * @param    sdids    Optional parameter: Comma separated list of source device IDs (minimum: 1).
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @return    Returns the NormalizedMessagesEnvelope response from the API call 
     */
    public NormalizedMessagesEnvelope getLastNormalizedMessages(
                final Integer count,
                final String sdids,
                final String fieldPresence
    ) throws Throwable {
        APICallBackCatcher<NormalizedMessagesEnvelope> callback = new APICallBackCatcher<NormalizedMessagesEnvelope>();
        getLastNormalizedMessagesAsync(count, sdids, fieldPresence, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Last Normalized Message
     * @param    count    Optional parameter: Number of items to return per query.
     * @param    sdids    Optional parameter: Comma separated list of source device IDs (minimum: 1).
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @return    Returns the void response from the API call 
     */
    public void getLastNormalizedMessagesAsync(
                final Integer count,
                final String sdids,
                final String fieldPresence,
                final APICallBack<NormalizedMessagesEnvelope> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages/last");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5024341204369218441L;
            {
                    put( "count", count );
                    put( "sdids", sdids );
                    put( "fieldPresence", fieldPresence );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5278576706012013107L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            NormalizedMessagesEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<NormalizedMessagesEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Normalized Messages
     * @param    uid    Optional parameter: User ID. If not specified, assume that of the current authenticated user. If specified, it must be that of a user for which the current authenticated user has read access to.
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    mid    Optional parameter: The message ID being searched.
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @param    filter    Optional parameter: Filter.
     * @param    offset    Optional parameter: A string that represents the starting item, should be the value of 'next' field received in the last response. (required for pagination)
     * @param    count    Optional parameter: count
     * @param    startDate    Optional parameter: startDate
     * @param    endDate    Optional parameter: endDate
     * @param    order    Optional parameter: Desired sort order: 'asc' or 'desc'
     * @return    Returns the NormalizedMessagesEnvelope response from the API call 
     */
    public NormalizedMessagesEnvelope getNormalizedMessages(
                final String uid,
                final String sdid,
                final String mid,
                final String fieldPresence,
                final String filter,
                final String offset,
                final Integer count,
                final Long startDate,
                final Long endDate,
                final String order
    ) throws Throwable {
        APICallBackCatcher<NormalizedMessagesEnvelope> callback = new APICallBackCatcher<NormalizedMessagesEnvelope>();
        getNormalizedMessagesAsync(uid, sdid, mid, fieldPresence, filter, offset, count, startDate, endDate, order, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Normalized Messages
     * @param    uid    Optional parameter: User ID. If not specified, assume that of the current authenticated user. If specified, it must be that of a user for which the current authenticated user has read access to.
     * @param    sdid    Optional parameter: Source device ID of the messages being searched.
     * @param    mid    Optional parameter: The message ID being searched.
     * @param    fieldPresence    Optional parameter: String representing a field from the specified device ID.
     * @param    filter    Optional parameter: Filter.
     * @param    offset    Optional parameter: A string that represents the starting item, should be the value of 'next' field received in the last response. (required for pagination)
     * @param    count    Optional parameter: count
     * @param    startDate    Optional parameter: startDate
     * @param    endDate    Optional parameter: endDate
     * @param    order    Optional parameter: Desired sort order: 'asc' or 'desc'
     * @return    Returns the void response from the API call 
     */
    public void getNormalizedMessagesAsync(
                final String uid,
                final String sdid,
                final String mid,
                final String fieldPresence,
                final String filter,
                final String offset,
                final Integer count,
                final Long startDate,
                final Long endDate,
                final String order,
                final APICallBack<NormalizedMessagesEnvelope> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5230719494585371112L;
            {
                    put( "uid", uid );
                    put( "sdid", sdid );
                    put( "mid", mid );
                    put( "fieldPresence", fieldPresence );
                    put( "filter", filter );
                    put( "offset", offset );
                    put( "count", count );
                    put( "startDate", startDate );
                    put( "endDate", endDate );
                    put( "order", order );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4812512628530039324L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            NormalizedMessagesEnvelope _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<NormalizedMessagesEnvelope>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

    /**
     * Get Normalized Message Aggregates
     * @param    sdid    Required parameter: Source device ID of the messages being searched.
     * @param    field    Required parameter: Message field being queried for aggregates.
     * @param    startDate    Required parameter: Timestamp of earliest message (in milliseconds since epoch).
     * @param    endDate    Required parameter: Timestamp of latest message (in milliseconds since epoch).
     * @return    Returns the AggregatesResponse response from the API call 
     */
    public AggregatesResponse getMessageAggregates(
                final String sdid,
                final String field,
                final long startDate,
                final long endDate
    ) throws Throwable {
        APICallBackCatcher<AggregatesResponse> callback = new APICallBackCatcher<AggregatesResponse>();
        getMessageAggregatesAsync(sdid, field, startDate, endDate, callback);
        if(!callback.isSuccess())
            throw callback.getError();
        return callback.getResult();
    }

    /**
     * Get Normalized Message Aggregates
     * @param    sdid    Required parameter: Source device ID of the messages being searched.
     * @param    field    Required parameter: Message field being queried for aggregates.
     * @param    startDate    Required parameter: Timestamp of earliest message (in milliseconds since epoch).
     * @param    endDate    Required parameter: Timestamp of latest message (in milliseconds since epoch).
     * @return    Returns the void response from the API call 
     */
    public void getMessageAggregatesAsync(
                final String sdid,
                final String field,
                final long startDate,
                final long endDate,
                final APICallBack<AggregatesResponse> callBack
    ) {
        //the base uri for api requests
        String _baseUri = Configuration.getBaseUri();
        
        //prepare query string for API call
        StringBuilder _queryBuilder = new StringBuilder(_baseUri);
        _queryBuilder.append("/messages/analytics/aggregates");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(_queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5086873207640899755L;
            {
                    put( "sdid", sdid );
                    put( "field", field );
                    put( "startDate", startDate );
                    put( "endDate", endDate );
            }});
        //validate and preprocess url
        String _queryUrl = APIHelper.cleanUrl(_queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> _headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5010422387901640743L;
            {
                    put( "user-agent", "APIMATIC 2.0" );
                    put( "accept", "application/json" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest _request = getClientInstance().get(_queryUrl, _headers, null);

        //invoke the callback before request if its not null
        if (getHttpCallBack() != null)
        {
            getHttpCallBack().OnBeforeRequest(_request);
        }

        //invoke request and get response
        Runnable _responseTask = new Runnable() {
            public void run() {
                //make the API call
                getClientInstance().executeAsStringAsync(_request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext _context, HttpResponse _response) {
                        try {

                            //invoke the callback after response if its not null
                            if (getHttpCallBack() != null)	
                            {
                                getHttpCallBack().OnAfterResponse(_context);
                            }

                            //handle errors defined at the API level
                            validateResponse(_response, _context);

                            //extract result from the http response
                            String _responseBody = ((HttpStringResponse)_response).getBody();
                            AggregatesResponse _result = APIHelper.deserialize(_responseBody,
                                                        new TypeReference<AggregatesResponse>(){});

                            //let the caller know of the success
                            callBack.onSuccess(_context, _result);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(_context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(_context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(_context, exception);
                        }
                    }
                    public void onFailure(HttpContext _context, Throwable _error) {
                        //invoke the callback after response if its not null
                        if (getHttpCallBack() != null)	
                            {
                            getHttpCallBack().OnAfterResponse(_context);
                        }

                        //let the caller know of the failure
                        callBack.onFailure(_context, _error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(_responseTask);
    }

}